#######################################################################
#                     vim-supercollider-snippets                      #
#######################################################################

##############################################
#  global python functions used in snippets  #
##############################################
global !p
random_lfo_ugen_candidates = ["LFNoise0", "LFNoise1", "LFNoise2", "SinOsc", "LFSaw", "LFCub", "LFTri"]
random_sound_ugen_candidates = ["SinOsc", "Saw", "LFTri", "Blip"]

def ranfloat(minimum=0.0, maximum=1.0, roundto=2):
	ran = round(random.uniform(minimum, maximum), roundto)
	if not snip.c: snip.rv = ran

def ranfloat(minimum=0.0, maximum=1.0, roundto=2):
	ran = round(random.uniform(minimum, maximum), roundto)
	if not snip.c: snip.rv = ran

def ranarray(size=4, minimum=0.0, maximum=1.0, roundto=2):
	array = ""
	for i in range(0,size):
		ran = round(random.uniform(minimum, maximum), roundto)
		ran = "{}".format(ran)

		if i <= (size-2):
			ran += ", ".format(i)

		array += str(ran)
	array = "[" + array + "]"
	if not snip.c: snip.rv = array

def ranlfo():
	if not snip.c: snip.rv = random.choice(random_lfo_ugen_candidates)

def ransoundugen():
	if not snip.c: snip.rv = random.choice(random_sound_ugen_candidates)

def funkyline(width=40):
	line="/* "
	for i in range(0,width):
		randomchar = random.choice(["~", ",", ".", "-", "_"])
		line += str(randomchar)

	line += " */"

	return line

endglobal

#############
#  general  #
#############
snippet /head(er)?/ "File header containing common information" r
/*
`!p snip.rv = snip.basename.upper()`

${1:`echo $USER`}, ${2:`date +%Y`} 

${3:https://github.com/`!p snip.rv=t[1].lower().replace(" ", "")`}

${4:Tested using SuperCollider version `sclang -v|sed 's/sclang //'|sed 's/(.*)//'`}

*/
endsnippet

snippet line "A spacer line"
`!p if not snip.c: snip.rv = funkyline()`
endsnippet

snippet /ran(dfloat)/ "Random float" r
`!p ranfloat(0.0,1.0)`
endsnippet

snippet ranarray "Random array"
`!p ranarray()`
endsnippet

snippet startup "Common startup function"
~numChannels = ${1:2};
s.options.numOutputBusChannels_(~numChannels);

s.waitForBoot{
	fork{
		${3:b = Buffer.read(s, "${2:~/testsound/plastic1.wav}".asAbsolutePath);}
		${4:s.sync; "Done loading buffer".postln;}
	}
}
endsnippet

##############
#  Language  #
##############
snippet /func(tion)?/ "Function body" r
{${3:| ${1:argument} |}
	${2:// body}
}$0
endsnippet

snippet fork "Fork a function"
fork{
	${1:"Starting fork".postln;}	
	${2:1.wait;}
	${3:"Done waiting for fork".postln;}
}
endsnippet

snippet /rout(ine)?/ "Routine" r
Routine({
	${1:1000.yield;}
	${2:2.wait;}
	${3:2000.idle(${4:10}); // Wait $4 seconds to return}
	${5:"Done".postln;}
})${6:.play}
endsnippet

snippet task "A pausable process"
Task({
	${1:
	${2:50}.do({ arg i;
		${3:i.squared.postln;}
		${4:0.5.wait;}
	});}
})$0
endsnippet

snippet loop "Loop"
loop{
	${1:"Beginning of loop".postln;}
	${2:2.wait;}
	${3:"End of loop".postln;}
}
endsnippet

########################
#  Control Structures  #
########################
snippet if "Description of snippet"
if(${1:true}, {${2:"Expressions was true".postln}}, {${3:"Expression was false".postln}})
endsnippet

snippet /swi(tch)?/ "Switch conditional" r
switch(${1:somevariable})
	{${2:1}} {${3:"It's 1".postln}}
	${6:{${4:10000}} {${5:"It's 10000!".postln}}}$0
endsnippet

snippet case "Conditional evalutaion with multiple cases"
case
	{ ${1:i} ${2:== 1} } { ${3:\no} }
	{ $1 ${4:== 1.1} } { ${5:\wrong} }
	{ $1 ${6:== 1.9} } { ${7:\ok} }$0
endsnippet

#############################
#  Collection manipulation  #
#############################

snippet do "Do"
do{${3:|${1:i}|} ${2:i.postln}}
endsnippet

snippet /rev(ersedo)?/ "Reverse do" r
reverseDo{${3:|${1:i}|} ${2:i.postln}}
endsnippet

snippet /coll(ect)?/ "Collect" r
collect{${3:|${1:i}|} ${2:i * 20}}
endsnippet

snippet /sel(ect)?/ "select" r
select{${3:|${1:i}|} ${2:i * 20}}
endsnippet

snippet /rej(ect)?/ "reject" r
reject{${3:|${1:i}|} ${2:i ${5:==} ${4:20}}}$0
endsnippet

#############
#  classes  #
#############
snippet class "A SuperCollider class"
${1:MyClass}{

	*new { | ${2: arga, argb, argc} |
		^super.new.init($2)
	}

	init { | $2 |
	${0}
	}
}
endsnippet

snippet pseudo "A pseudo ugen class"
${1:Reverb1} {
	*${2:ar}{|${4:in}|
		var sig = ${3:AllpassN.ar(in, 0.05, 0.05.rand, 1.0)};
		^sig
	}
}
endsnippet

####################
#  synthdef stuff  #
####################

snippet /sy(nthdef)?/ "SynthDef" r
SynthDef(\\${1:name}, { | ${2:freq=444}${4:,${3:out=0}} |
	var sig = ${5:`!p ransoundugen()`.ar(freq)};
	
	${6:sig = LPF.ar(sig);}

	${7:Out}.ar(out, sig)
}).${8:add}$0
endsnippet

snippet wrap "Insert functions in a SynthDef"
${2:var sig = ${1:SinOsc.ar(414)};}
SynthDef.wrap(${3:{|${5:in}, freq| $5 * SinOsc.ar(freq)}}, prependArgs: [${4:sig}]);
endsnippet

############
#  JITLib  #
############

snippet /nd(ef)?/ "Ndef" r
${2:// $1}
Ndef(\\${1:name}, {${0:}});
endsnippet

snippet spec "ControlSpec"
Spec.add(\\${1:helpExp}, ControlSpec( minVal: ${2:0.01}, maxVal: ${3:1.0}, warp: \\${4:exp}, step: ${5:0.0}, default: ${6:0.5}));
endsnippet

snippet npf "NodeProxy Filter"
Ndef(\\${1:name})[${2:1}] = \\${3:filter} -> ${5:{${4:|in|} ${0}}};
endsnippet

snippet /nds(ampler)?/ "Ndef sampleplayer" r
Ndef(\\${2:sampleplayer$1}, {|buffer, rate=1, trigger=1, start=0, loop=1|
	PlayBuf.ar(${1:2}, buffer, rate * BufRateScale.kr(buffer), trigger, start, loop,  doneAction: ${3:0});
}).set(\buffer, ${4:b})${5:.play};
endsnippet

snippet /ndn(oise)?/ "Ndef noise" r
Ndef(\\${2:noise$1}, {|freq=${3:`!p ranfloat(0.01,10.0)`}, minVal=${4:0.0}, maxVal=${5:1.0}|
	LFNoise${1:2}.kr(freq).range(minVal, maxVal)
});
endsnippet

snippet /ndl(fo)?/ "Ndef LFO" r
Ndef(\\${2:`!p if not snip.c: snip.rv = "lfo_"+str(random.randint(1,1000))`}, {|freq=${3:`!p ranfloat(0.01,10.0)`}, minVal=${4:0.0}, maxVal=${5:1.0}|
	${1:`!p ranlfo()`}.kr(freq).range(minVal, maxVal)
})${0};
endsnippet

snippet /ndm(ap)?/ "Ndef mapping" r
Ndef(\\${1:receivingNdef}).map(\\${2:freq}, Ndef(\\${3:lfo}))${0};
endsnippet

snippet /ndla(g)?/ "Ndef argument lag" r
Ndef(\\${1:lagThis}).lag(\\${2:freq}, ${3:1.0});
endsnippet

snippet /ndf(adetime)?/ "Ndef cross fade time" r
Ndef(\\${1:fadeThis}).fadeTime_(${2:1});
endsnippet

snippet /ndc(copy)?/ "Ndef copying" r
Ndef(\\${1:copyThis}).copy(\\${2:toThis});
${3:Ndef(\\$2).set(\\${4:freq}, ${5:`!p ranfloat(0.01,10.0)`});}
endsnippet

snippet /ndg(ui)?/ "Ndef gui" r
Ndef(\\${1:guiThis}).gui;
endsnippet

snippet /nds(et)?/ "Set Ndef" r
Ndef(\\${1:setThis}).set(\\${2:paramName}, ${3: `!p ranfloat()`})
endsnippet

##############
#  patterns  #
##############

snippet /ps(eg)?/ "Pseg" r
Pseg(Pseq(${1:`!p ranarray(random.randint(3,6), 0.001,1.0)`}), ${2:`!p ranfloat(0.5,4.0)`}, ${3:Pwhite(`!p ranfloat()`,`!p ranfloat(1.0,10.0)`)}, ${4:inf})
endsnippet

# Value patterns
snippet pseq "Pseq with random list"
Pseq(${1:`!p ranarray(random.randint(3,10), 0.1, 1.0)`}, ${2:inf})
endsnippet

snippet /pra(nd)?/ "Prand with random list" r
Prand(${1:`!p ranarray(random.randint(3,10), 0.1, 1.0)`}, ${2:inf})
endsnippet

snippet /pxra(nd)?/ "Pxrand with random list" r
Pxrand(${1:`!p ranarray(random.randint(3,10), 0.1, 1.0)`}, ${2:inf})
endsnippet

snippet /psh(uf)?/ "Pshuf" r
Pshuf(${1:`!p ranarray(random.randint(3,10), 0.1, 1.0)`}, ${2:inf})
endsnippet

snippet /pwh(ite)?/ "Pwhite" r
Pwhite(${1:`!p ranfloat(0.0,1.0)`}, ${2:`!p ranfloat(1.0,2.0)`})
endsnippet

snippet /pexp(rand)?/ "Pexprand" r
Pexprand(${1:`!p ranfloat(0.1,1.0)`}, ${2:`!p ranfloat(100.0,1500.0)`})
endsnippet

snippet /pbr(own)?/ "Pbrown" r
Pbrown(${1:`!p ranfloat(0.0,1.0)`}, ${2:`!p ranfloat(1.0,2.0)`}, ${3:`!p ranfloat(0.01,0.1)`})
endsnippet

# Event patterns
snippet /pd(ef)?/ "Pdef" r
Pdef('${1:name}', 
	${2:Pbind(
		\\${5:instrument},${5:\\default},
		\\${3:dur},${4:`!p ranfloat(0.1,1.0)`},
	)}
);
endsnippet

snippet pspawn "Pspawn"
Pspawn(
	Pbind(
		\delta, Pwhite(`!p ranfloat(0.25,4.0)`, `!p ranfloat(0.25,4.0)`, inf),
		\\${2:customParam}, ${3:Pwhite(0.0,1.0)},
		\method, ${1:Pseq([\par, \seq], inf)},
		\pattern, Pfunc { |ev|
			var $2 = ev[\\$2];

			Pbind(
				\instrument, \\${4:default},
				\freq, Pwhite(40.0,500.0) * $2,
				\dur, 0.125$0
			) 
		},
	)
);
endsnippet

snippet /plam(bda)/ "Parallel Plambda example" r
Plambda(
	Ppar([
		Pbind(
			\degree, Pseq([0,1,2],inf),
			\dur, Plet(${1:\\primaryDur}, pattern: ${2:Pseq(`!p ranarray(4, 0.25,1.0)`,inf)}), 
		),
		Pbind(
			\degree, ${6:Pseq([0,2,3], inf)},
			${5:\octave, 4,}
			\dur, ${4: 2 * }Pget($1, default: ${3:1}, repeats: inf),
		)
	])
)
endsnippet

############
#  Events  #
############

snippet eventtype "A custom event type"
// Event type: $1
Event.addEventType(\\${1:newEventType}, {|server|
	~type = ${2:\note}; // Inherit from this eventtype
	${0}

	${3:currentEnvironment.play;}
})
endsnippet

######################
#  controller stuff  #
######################
