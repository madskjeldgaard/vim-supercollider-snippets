#############
#  general  #
#############
snippet startup "Common startup function"
~numChannels = ${1:2};
s.options.numOutputBusChannels_(~numChannels);

s.waitForBoot{
	fork{
		${3:b = Buffer.read(s, "${2:~/testsound/plastic1.wav}".asAbsolutePath);}
		${4:s.sync; "Done loading buffer".postln;}
	}
}
endsnippet

##############
#  Language  #
##############
snippet /f(unction)?/ "Function body" r
{${3:| ${1:argument} |}
	${2:// body}
}$0
endsnippet

snippet /fo(rk)?/ "Fork a function" r
fork{
	${1:"Starting fork".postln;}	
	${2:1.wait;}
	${3:"Done waiting for fork".postln;}
}
endsnippet

snippet /ro(outine)?/ "Routine" r
Routine({
	${1:1000.yield;}
	${2:2.wait;}
	${3:2000.idle(${4:10}); // Wait $4 seconds to return}
	${5:"Done".postln;}
})${6:.play}
endsnippet

snippet /ta(sk)?/ "A pausable process" r
Task({
	${1:
	${2:50}.do({ arg i;
		${3:i.squared.postln;}
		${4:0.5.wait;}
	});}
})$0
endsnippet

snippet /lo(op)?/ "Loop" r
loop{
	${1:"Beginning of loop".postln;}
	${2:2.wait;}
	${3:"End of loop".postln;}
}
endsnippet

########################
#  Control Structures  #
########################
snippet /i(f)?/ "Description of snippet" r
if(${1:true}, {${2:"Expressions was true".postln}}, {${3:"Expression was false".postln}})
endsnippet

snippet /sw(itch)?/ "Switch conditional" r
switch(${1:somevariable})
	{${2:1}} {${3:"It's 1".postln}}
	${6:{${4:10000}} {${5:"It's 10000!".postln}}}$0
endsnippet

snippet /ca(se)?/ "Conditional evalutaion with multiple cases" r
case
	{ ${1:i} ${2:== 1} } { ${3:\no} }
	{ $1 ${4:== 1.1} } { ${5:\wrong} }
	{ $1 ${6:== 1.9} } { ${7:\ok} }$0
endsnippet

#############################
#  Collection manipulation  #
#############################

snippet /d(o)?/ "Do" r
do{${3:|${1:i}|} ${2:i.postln}}
endsnippet

snippet /rev(ersedo)?/ "Reverse do" r
reverseDo{${3:|${1:i}|} ${2:i.postln}}
endsnippet

snippet /co(llect)?/ "Collect over collectable" r
collect{${3:|${1:i}|} ${2:i * 20}}
endsnippet

snippet /se(lect)?/ "select" r
select{${3:|${1:i}|} ${2:i * 20}}
endsnippet

snippet /re(ject)?/ "reject" r
reject{${3:|${1:i}|} ${2:i == 20}}
endsnippet

#############
#  classes  #
#############
snippet /cl(ass)?/ "A SuperCollider class" r
${1:MyClass}{

	*new { | ${2: arga, argb, argc} |
		^super.new.init($2)
	}

	init { | $2 |
	${0}
	}
}
endsnippet

snippet pseudo "A pseudo ugen class"
${1:Rever1} {
	*${2:ar}{|${4:in}|
		var sig = ${3:AllpassN.ar(in, 0.05, 0.05.rand, 1.0)};
		^sig
	}
}
endsnippet

####################
#  synthdef stuff  #
####################

snippet wrap "Insert functions in a SynthDef"
${2:var sig = ${1:SinOsc.ar(414)};}
SynthDef.wrap(${3:{|${5:in}, freq| $5 * SinOsc.ar(freq)}}, prependArgs: [${4:sig}]);
endsnippet

############
#  JITLib  #
############

snippet /nd(ef)?/ "Ndef" r
${2:// $1}
Ndef(\\${1:name}, {${0:}});
endsnippet

snippet spec "ControlSpec"
Spec.add(\\${1:helpExp}, ControlSpec( minVal: ${2:0.01}, maxVal: ${3:1.0}, warp: \\${4:exp}, step: ${5:0.0}, default: ${6:0.5}));
endsnippet

snippet npf "NodeProxy Filter"
Ndef(\\${1:name})[${2:1}] = \\${3:filter} -> ${5:{${4:|in|} ${0}}};
endsnippet

snippet /nds(ampler)?/ "Ndef sampleplayer" r
Ndef(\\${2:sampleplayer$1}, {|buffer, rate=1, trigger=1, start=0, loop=1|
	PlayBuf.ar(${1:2}, buffer, rate * BufRateScale.kr(buffer), trigger, start, loop,  doneAction: ${3:0});
}).set(\buffer, ${4:b})${5:.play};
endsnippet

snippet /ndn(oise)?/ "Ndef noise" r
Ndef(\\${2:noise$1}, {|freq=${3:10.0}, minVal=${4:0.0}, maxVal=${5:0.0}|
	LFNoise${1:2}.kr(freq).range(minVal, maxVal)
});
endsnippet

snippet /ndl(fo)?/ "Ndef LFO" r
Ndef(\\${2:lfo$1}, {|freq=${3:10.0}, minVal=${4:0.0}, maxVal=${5:0.0}|
	${1:LFPar}.kr(freq).range(minVal, maxVal)
})${0};
endsnippet

snippet /ndm(ap)?/ "Ndef mapping" r
Ndef(\\${1:receivingNdef}).map(\\${2:freq}, Ndef(\\${3:lfo}))${0};
endsnippet

snippet /ndl(ag)?/ "Ndef argument lag" r
Ndef(\\${1:lagThis}).lag(\\${2:freq}, ${3:1.0});
endsnippet

snippet /ndf(adetime)?/ "Ndef cross fade time" r
Ndef(\\${1:lagThis}).fadeTime_(${2:1});
endsnippet

snippet /ndc(copy)?/ "Ndef copying" r
Ndef(\\${1:copyThis}).copy(\\${2:toThis});
${3:Ndef(\\$2).set(\\${4:freq}, ${5:0.234});}
endsnippet

snippet /ndg(ui)?/ "Ndef gui" r
Ndef(\\${1:guiThis}).gui;
endsnippet

##############
#  patterns  #
##############

snippet /pd(ef)?/ "Pdef" r
Pdef('${1:name}', 
	${2:Pbind(
		\\${5:instrument},${5:\\default},
		\\${3:dur},${4:1},
	)}
);
endsnippet

snippet /ps(pawn)?/ "Pspawn" r
Pspawn(
	Pbind(
		\delta, Pwhite(1, 5, inf) * 0.125,
		\\${2:customParam}, ${3:Pwhite(0.0,1.0)},
		\method, ${1:Pseq([\par, \seq], inf)},
		\pattern, Pfunc { |ev|
			var $2 = ev[\\$2];

			Pbind(
				\instrument, \\${4:default},
				\freq, Pwhite(40.0,500.0) * $2,
				\dur, 0.125$0
			) 
		},
	)
);
endsnippet

snippet /pl(ambda)/ "Parallel Plambda example" r
Plambda(
	Ppar([
		Pbind(
			\degree, Pseq([0,1,2],inf),
			\dur, Plet(${1:\\primaryDur}, pattern: ${2:Pseq([0.25, 0.25, 0.125, 0.5, 1],inf)}), 
		),
		Pbind(
			\degree, ${6:Pseq([0,2,3], inf)},
			${5:\octave, 4,}
			\dur, ${4: 2 * }Pget($1, default: ${3:1}, repeats: inf),
		)
	])
)
endsnippet

snippet ps "Pseg"
Pseg(Pseq(${1:[0.0,1.0,0.0]}), ${2:1}, ${3:Pwhite(1.0,10.0)}, ${4:inf})
endsnippet

############
#  Events  #
############

snippet eventtype "A custom event type"
// Event type: $1
Event.addEventType(\\${1:newEventType}, {|server|
	~type = ${2:\note}; // Inherit from this eventtype
	${0}

	currentEnvironment.play;
})
endsnippet

######################
#  controller stuff  #
######################
